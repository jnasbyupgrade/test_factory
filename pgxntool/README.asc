= PGXNtool
Easier PGXN development
:sectlinks:
:sectanchors:
:toc:
:numbered:

PGXNtool is meant to make developing new Postgres extensions for http://pgxn.org[PGXN] easier.

Currently, it consists a base Makefile that you can include instead of writing your own, a template META.json, and some test framework. More features will be added over time.

If you find any bugs or have ideas for improvements, please https://github.com/decibel/pgxntool/issues[*open an issue*].

== Install
This assumes that you've already initialized your extension in git.

NOTE: The `--squash` is important! Otherwise you'll clutter your repo with a bunch of commits you probably don't want.

----
git subtree add -P pgxntool --squash git@github.com:decibel/pgxntool.git release
pgxntool/setup.sh
----

TODO: Create a nice script that will init a new project for you.

== Development

If you want to contribute to pgxntool development, work from the https://github.com/decibel/pgxntool-test[pgxntool-test] repository, not from this repository. That repository contains the test infrastructure and development tools needed to validate changes to pgxntool. This repository contains only the framework files that get embedded into extension projects via `git subtree`.

== Usage
Typically, you can just create a simple Makefile that does nothing but include base.mk:

----
include pgxntool/base.mk
----

== make targets
These are the make targets that are provided by base.mk

NOTE: all the targets normally provided by Postgres http://www.postgresql.org/docs/current/static/extend-pgxs.html[PGXS] still work.

=== html
This will build any .html files that can be created. See <<_Document_Handling>>.

=== test
Runs unit tests via the PGXS `installcheck` target. Unlike a simple `make installcheck` though, the `test` rule has the following prerequisites: clean testdeps install installcheck. All of those are PGXS rules, except for `testdeps`.

NOTE: While you can still run `make installcheck` or any other valid PGXS make target directly, it's recommended to use `make test` when using pgxntool. The `test` target ensures clean builds, proper test isolation, and correct dependency installation.

=== testdeps
This rule allows you to ensure certain actions have taken place before running tests. By default it has a single prerequisite, `pgtap`, which will attempt to install http://pgtap.org[pgtap] from PGXN. This depneds on having the pgxn client installed.

You can add any other dependencies you want by simply adding another `testdeps` rule. For example:

testdeps example from https://github.com/decibel/test_factory/blob/493020d29ba976c38a98e7f1c68bfd89900f0e22/Makefile#L4[test_factory]
----
testdeps: check_control

.PHONY: check_control
check_control:
	grep -q "requires = 'pgtap, test_factory'" test_factory_pgtap.control
----

If you want to over-ride the default dependency on `pgtap` you should be able to do that with a makefile override. If you need help with that, please https://github.com/decibel/pgxntool/issues[open an issue].

WARNING: It will probably cause problems if you try to create a `testdeps` rule that has a recipe. Instead of doing that, put the recipe in a separate rule and make that rule a prerequisite of `testdeps` as show in the example.

=== results
Because `make test` ultimately runs `installcheck`, it's using the Postgres test suite. Unfortunately, that suite is based on running `diff` between a raw output file and expected results. I *STRONGLY* recommend you use http://pgtap.org[pgTap] instead! With pgTap, it's MUCH easier to determine whether a test is passing or not - tests explicitly pass or fail rather than requiring you to examine diff output. The extra effort of learning pgTap will quickly pay for itself. https://github.com/decibel/trunklet-format/blob/master/test/sql/base.sql[This example] might help get you started.

No matter what method you use, once you know that all your tests are passing correctly, you need to create or update the test output expected files. `make results` does that for you.

IMPORTANT: *`make results` requires manual verification first*. The correct workflow is:

1. Run `make test` and examine the diff output
2. Manually verify that the differences are correct and expected
3. Only then run `make results` to update the expected output files in `test/expected/`

Never run `make results` without first verifying the test changes are correct. The `results` target copies files from `test/results/` to `test/expected/`, so running it blindly will make incorrect output become the new expected behavior.

=== tag
`make tag` will create a git branch for the current version of your extension, as determined by the META.json file. The reason to do this is so you can always refer to the exact code that went into a released version.

If there's already a tag for the current version that probably means you forgot to update META.json, so you'll get an error. If you're certain you want to over-write the tag, you can do `make forcetag`, which removes the existing tag (via `make rmtag`) and creates a new one.

WARNING: You will be very unhappy if you forget to update the .control file for your extension! There is an https://github.com/decibel/pgxntool/issues/1[open issue] to improve this.

=== dist
`make dist` will create a .zip file for your current version that you can upload to PGXN. The file is named after the PGXN name and version (the top-level "name" and "version" attributes in META.json). The .zip file is placed in the *parent* directory so as not to clutter up your git repo.

NOTE: Part of the `clean` recipe is cleaning up these .zip files. If you accidentally clean before uploading, just run `make dist-only`.

=== pgxntool-sync
This rule will pull down the latest released version of PGXNtool via `git subtree pull`.

NOTE: Your repository must be clean (no modified files) in order to run this. Running this command will produce a git commit of the merge.

TIP: There is also a `pgxntool-sync-%` rule if you need to do more advanced things.

=== pgtle
Generates pg_tle (Trusted Language Extensions) registration SQL files for deploying extensions in managed environments like AWS RDS/Aurora. See <<_pg_tle_Support>> for complete documentation.

`make pgtle` generates SQL files in `pg_tle/` subdirectories organized by pg_tle version ranges. For version range details, see `pgtle_versions.md`.

=== check-pgtle
Checks if pg_tle is installed and reports the version. This target:
- Reports the version from `pg_extension` if `CREATE EXTENSION pg_tle` has been run in the database
- Errors if pg_tle is not available in the cluster

This target assumes `PG*` environment variables are configured for `psql` connectivity.

----
make check-pgtle
----

=== run-pgtle
Registers all extensions with pg_tle by executing the generated pg_tle registration SQL files in a PostgreSQL database. This target:
- Requires pg_tle extension to be installed (checked via `check-pgtle`)
- Uses `pgtle.sh` to determine which version range directory to use based on the installed pg_tle version
- Runs all generated SQL files via `psql` to register your extensions with pg_tle

This target assumes that running `psql` without any arguments will connect to the desired database. You can control this by setting the various PG* environment variables (and possibly using the `.pgpassword` file). See the PostgreSQL documentation for more details.

NOTE: The `pgtle` target is a dependency, so `make run-pgtle` will automatically generate the SQL files if needed.

----
make run-pgtle
----

After running `make run-pgtle`, you can create your extension in the database:
----
CREATE EXTENSION "your-extension-name";
----

== Version-Specific SQL Files

PGXNtool automatically generates version-specific SQL files from your base SQL file. These files follow the pattern `sql/{extension}--{version}.sql` and are used by PostgreSQL's extension system to install specific versions of your extension.

=== How Version Files Are Generated

When you run `make` (or `make all`), PGXNtool:

1. Reads your `META.json` file to determine the extension version from `provides.{extension}.version`
2. Generates a Makefile rule that copies your base SQL file (`sql/{extension}.sql`) to the version-specific file (`sql/{extension}--{version}.sql`)
3. Executes this rule, creating the version-specific file with a header comment indicating it's auto-generated

For example, if your `META.json` contains:
----
"provides": {
  "myext": {
    "version": "1.2.3",
    ...
  }
}
----

Running `make` will create `sql/myext--1.2.3.sql` by copying `sql/myext.sql`.

=== What Controls the Version Number

The version number comes from `META.json` → `provides.{extension}.version`, *not* from your `.control` file's `default_version` field. The `.control` file's `default_version` is used by PostgreSQL to determine which version to install by default, but the actual version-specific file that gets generated is determined by what's in `META.json`.

To change the version of your extension:
1. Update `provides.{extension}.version` in `META.json`
2. Run `make` to regenerate the version-specific file
3. Update `default_version` in your `.control` file to match (if needed)

=== Committing Version Files

Version-specific SQL files are now treated as permanent files that should be committed to your repository. This makes it much easier to test updates to extensions, as you can see exactly what SQL was included in each version.

IMPORTANT: These files are auto-generated and include a header comment warning not to edit them. Any manual changes will be overwritten the next time you run `make`. To modify the extension, edit the base SQL file (`sql/{extension}.sql`) instead.

=== Alternative: Ignoring Version Files

If you prefer not to commit version-specific SQL files, you must add them to your `.gitignore` to prevent `make dist` from failing due to untracked files. Add the following to your `.gitignore`:

----
# Auto-generated version-specific SQL files (if not committing them)
sql/*--*.sql
!sql/*--*--*.sql
----

The second line (`!sql/*--*--*.sql`) ensures that upgrade scripts (which contain two version numbers and should be manually written) are still tracked.

WARNING: If you ignore version files instead of committing them, they will NOT be included in your PGXN distribution (`make dist` uses `git archive`, which only includes tracked files). This means users installing your extension from PGXN will need `make` and PGXS available to build the extension - they cannot simply copy the SQL files into their PostgreSQL installation. For maximum compatibility, we recommend committing version files.

=== Distribution Inclusion

Version-specific files are included in distributions created by `make dist` only if they are committed to git. Since `make dist` uses `git archive`, only tracked files are included in the distribution archive.

=== Multiple Versions

If you need to support multiple versions of your extension:

1. Create additional version-specific files manually (e.g., `sql/myext--1.0.0.sql`, `sql/myext--1.1.0.sql`)
2. Create upgrade scripts for version transitions (e.g., `sql/myext--1.0.0--1.1.0.sql`)
3. Update `META.json` to reflect the current version you're working on
4. Commit all version files and upgrade scripts to your repository

The version file for the current version (specified in `META.json`) will be automatically regenerated when you run `make`, but other version files you create manually will be preserved.

== Document Handling
PGXNtool supports generation and installation of document files. There are several variables and rules that control this behavior.

It is recommended that you commit any generated documentation files (such as HTML generated from Asciidoc) into git.
That way users will have these files installed when they install your extension.
If any generated files are missing (or out-of-date) during installation, PGXNtool will build them if Asciidoc is present on the system.

=== Document Variables
DOC_DIRS::
Directories to look for documents in.
Defined as `+= doc`.
DOCS::
PGXS variable.
See <<_the_docs_variable>> below.
DOCS_HTML::
Document HTML files.
PGXNtool appends `$(ASCIIDOC_HTML) to this variable.

ASCIIDOC::
Location of `asciidoc` or equivalent executable.
If not set PGXNtool will search for first `asciidoctor`, then `asciidoc`.
ASCIIDOC_EXTS::
File extensions to consider as Asciidoc.
Defined as `+= adoc asciidoc`.
ASCIIDOC_FILES::
Asciidoc input files.
PGXNtool searches each `$(DOC_DIRS)` directory, looking for files with any `$(ASCIIDOC_EXTS)` extension.
Any files found are added to `ASCIIDOC_FILES` using `+=`.
ASCIIDOC_FLAGS::
Additional flags to pass to Asciidoc.
ASCIIDOC_HTML::
PGXNtool replaces each `$(ASCIIDOC_EXTS)` in `$(ASCIIDOC_FILES)` with `html`.
The result is appended to `ASCIIDOC_HTML` using `+=`.

=== Document Rules
If Asciidoc is found (or `$(ASCIIDOC)` is set), the `html` rule will be added as a prerequisite to the `install` and `installchec` rules.
That will ensure that docs are generated for install and test, but only if Asciidoc is available.
The `dist` rule will always depend on `html` though, to ensure html files are up-to-date before creating a distribution.

The `html` rule simply depends on `$(ASCIIDOC_HTML).
This rule is always present.

For each Asciidoc extension in `$(ASCIIDOC_EXTS)` a rule is generated to build a .html file from that extension using `$(ASCIIDOC)`.
These rules are generated from `ASCIIDOC_template`:

.ASCIIDOC_template
[source,Makefile]
----
define ASCIIDOC_template
%.html: %.$(1) # <1>
ifndef ASCIIDOC
	$$(warning Could not find "asciidoc" or "asciidoctor". Add one of them to your PATH,)
	$$(warning or set ASCIIDOC to the correct location.)
	$$(error Could not build %$$@)
endif # ifndef ASCIIDOC
	$$(ASCIIDOC) $$(ASCIIDOC_FLAGS) $$<
endef # define ASCIIDOC_template
----
<1> `$(1)` is replaced by the extension.

These rules will *always* exist, even if `$(ASCIIDOC)` isn't set (ie: if Asciidoc wasn't found on the system).
These rules will throw an error if they are run if `$(ASCIIDOC)` isn't defined.
On a normal user system that should never happen, because the `html` rule won't be included in `install` or `installcheck`.

=== The DOCS variable
This variable has special meaning to PGXS.
See the Postgres documentation for full details.

If DOCS is defined when PGXS is included then rules will be added to install everything defined by $(DOCS) in `PREFIX/share/doc/extension`.

NOTE: If DOCS is defined but empty some of the PGXS targets will error out.
Because of this, `base.mk` will forcibly define it to be NULL if it's empty.

PGXNtool appends *all* files found in all `$(DOC_DIRS)` to `DOCS`.

== pg_tle Support
[[_pg_tle_Support]]
pgxntool can generate link:https://github.com/aws/pg_tle[pg_tle (Trusted Language Extensions)] registration SQL for deploying PostgreSQL extensions in managed environments like AWS RDS and Aurora where filesystem access is not available.

For make targets, see: <<_pgtle>>, <<_check_pgtle>>, <<_run_pgtle>>.

=== What is pg_tle?

pg_tle is an AWS open-source framework that enables developers to create and deploy PostgreSQL extensions without filesystem access. Traditional PostgreSQL extensions require `.control` and `.sql` files on the filesystem, which isn't possible in managed services like RDS and Aurora.

pg_tle solves this by:
- Storing extension metadata and SQL in database tables
- Using the `pgtle_admin` role for administrative operations
- Enabling `CREATE EXTENSION` to work in managed environments

=== Quick Start

Generate pg_tle registration SQL for your extension:

----
make pgtle
----

This creates files in `pg_tle/` subdirectories organized by pg_tle version ranges. See `pgtle_versions.md` for complete version range details and API compatibility boundaries.

=== Version Groupings

pgxntool creates different sets of files for different pg_tle versions to handle backward-incompatible API changes. Each version boundary represents a change to pg_tle's API functions that we use.

For details on version boundaries and API changes, see `pgtle_versions.md`.

=== Installation Example

IMPORTANT: This is only a basic example. Always refer to the link:https://github.com/aws/pg_tle[main pg_tle documentation] for complete installation instructions and best practices.

Basic installation steps:

. Ensure pg_tle is installed and grant the `pgtle_admin` role to your user
. Generate and run the pg_tle registration SQL files:
+
----
make run-pgtle
----
+
This automatically detects your pg_tle version and runs the appropriate SQL files. See `pgtle_versions.md` for version range details.
. Create your extension: `CREATE EXTENSION myextension;`

=== Advanced Usage

==== Multi-Extension Projects

If your project has multiple extensions (multiple `.control` files), `make pgtle` generates files for all of them:

----
myproject/
├── ext1.control
├── ext2.control
└── pg_tle/
    ├── 1.0.0-1.5.0/
    │   ├── ext1.sql
    │   └── ext2.sql
    └── 1.5.0+/
        ├── ext1.sql
        └── ext2.sql
----

=== How It Works
`make pgtle` does the following:

. Parses control file(s): Extracts `comment`, `default_version`, `requires`, and `schema` fields
. Discovers SQL files: Finds all versioned files (`sql/{ext}--{version}.sql`) and upgrade scripts (`sql/{ext}--{ver1}--{ver2}.sql`)
. Wraps SQL content: Uses a fixed dollar-quote delimiter (`$_pgtle_wrap_delimiter_$`) to wrap SQL for pg_tle functions
. Generates registration SQL: Creates `pgtle.install_extension()` calls for each version, `pgtle.install_update_path()` for upgrades, and `pgtle.set_default_version()` for the default
. Version-specific output: Generates separate files for different pg_tle capability levels

Each generated SQL file is wrapped in a transaction (`BEGIN;` ... `COMMIT;`) to ensure atomic installation.

=== Troubleshooting

==== "No versioned SQL files found"

*Problem*: The script can't find `sql/{ext}--{version}.sql` files.

*Solution*: Run `make` first to generate versioned files from your base `sql/{ext}.sql` file.

==== "Control file not found"

*Problem*: The script can't find `{ext}.control` in the current directory.

*Solution*: Run `make pgtle` from your extension's root directory (where the `.control` file is).

==== "SQL file contains reserved pg_tle delimiter"

*Problem*: Your SQL files contain the string `$_pgtle_wrap_delimiter_$` (extremely unlikely).

*Solution*: Don't use that dollar-quote delimiter in your code.

==== Extension uses C code

*Problem*: Your control file has `module_pathname`, indicating C code.

*Solution*: pg_tle only supports trusted languages. You cannot use C extensions with pg_tle. The script will warn you but still generate files (which won't work).

NOTE: there are several untrusted languages (such as plpython), and the only tests for C.
== Copyright
Copyright (c) 2026 Jim Nasby <Jim.Nasby@gmail.com>

PGXNtool is released under a https://github.com/decibel/pgxntool/blob/master/LICENCE[BSD license]. Note that it includes https://github.com/dominictarr/JSON.sh[JSON.sh], which is released under a https://github.com/decibel/pgxntool/blob/master/JSON.sh.LICENCE[MIT license].
